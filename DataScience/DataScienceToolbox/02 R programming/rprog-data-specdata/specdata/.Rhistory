index_1=sbux_df[sbux_df$Adj.Close[[which(sbux_df$Date == "3/1/1994")]]
)
index_1=sbux_df[sbux_df$Adj.Close[which(sbux_df$Date == "3/1/1994")]
)
index_1=sbux_df[which(sbux_df$Date == "3/1/1994"), sbux_df$Adj.Close]
index_1=sbux_df[which(sbux_df$Date == "3/1/1994"),"sbux_df$Adj.Close"]
index_2=sbux_df[which(sbux_df$Date == "3/1/1995"),"sbux_df$Adj.Close"]
some_prices=sbux_df[which(sbux_df$Date == "3/1/1994")..which(sbux_df$Date == "3/1/1995"),"sbux_df$Adj.Close"]
some_prices=sbux_df[which(sbux_df$Date == "3/1/1994"):which(sbux_df$Date == "3/1/1995"),"sbux_df$Adj.Close"]
View(some_prices)
which(sbux_df$Date == "3/1/1994")
index_1=sbux_df[which(sbux_df$Date == "3/1/1994"),"Adj.Close"]
index_2=sbux_df[which(sbux_df$Date == "3/1/1995"),"Adj.Close"]
some_prices=sbux_df[which(sbux_df$Date == "3/1/1994")..which(sbux_df$Date == "3/1/1995"),"Adj.Close"]
some_prices=sbux_df[which(sbux_df$Date == "3/1/1994"):which(sbux_df$Date == "3/1/1995"),"Adj.Close"]
index_1 = which(sbux_df$Date == "3/1/1994")
index_2 = which(sbux_df$Date == "3/1/1995")
# Extract prices between 3/1/1994 and 3/1/1995
some_prices = sbux_df[index_1, index_2,"Adj.Close"]
some_prices = sbux_df[index_1:index_2,"Adj.Close"]
sbux_prices_df = sbux_df[, "Adj.Close", drop=FALSE]
rownames(sbux_prices_df) = sbux_df$Date
head(sbux_prices_df)
price_1 = sbux_prices_df["3/1/1994", 1]
price_2 = sbux_prices_df["3/1/1995", 1]
plot(sbux_df$Adj.Close, type="l", col="blue", lwd=2, ylab="Adjusted close", main="Monthly closing price of SBUX")
sbux_prices_df = sbux_df[, "Adj.Close", drop=FALSE]
n = nrow(sbux_prices_df)
sbux_ret = (sbux_prices_df[2:n,1] - sbux_prices_df[1:(n-1),1]) / sbux_prices_df[1:(n-1),1]
View(sbux_prices_df)
class(sbux_ret)
names(sbux_ret) = some_names
n = nrow(sbux_prices_df)
names(sbux_ret)=sbux_df[2:n,"Date"]
View(sbux_df)
n = nrow(sbux_prices_df)
names(sbux_ret)=sbux_df[2:n,"Date"]
# The sbux_df data frame is already loaded in your work space
sbux_prices_df = sbux_df[, "Adj.Close", drop=FALSE]
# Denote n the number of time periods:
n = nrow(sbux_prices_df)
sbux_ret = ((sbux_prices_df[2:n, 1] - sbux_prices_df[1:(n-1), 1])/sbux_prices_df[1:(n-1), 1])
# Compute continuously compounded 1-month returns
sbux_ccret=log(sbux_prices_df[2:n, 1]) - log(sbux_prices_df[1:(n-1), 1])
# Assign names to the continuously compounded 1-month returns
names(sbux_ccret) = sbux_ref[2:n, "Date"]
# Show sbux_ccret
head(sbux_ccret)
names(sbux_ccret) = sbux_df[2:n, "Date"]
head(sbux_ccret)
? cbind
cbind(sbux_ret, sbux_ccret)
plot(sbux_ret, type="l", col="blue", lwd=2, ylab="Return",
main="Monthly Returns on SBUX")
abline(h=0)
legend(x="bottomright", legend=c("Simple", "CC"),
lty=1, lwd=2, col=c("blue","red"))
plot(sbux_ret, type="l", col="red", lwd=2, ylab="Return",
+      main="Monthly Returns on SBUX")
plot(sbux_ret, type="l", col="red", lwd=2, ylab="Return",    main="Monthly Returns on SBUX")
plot(sbux_ret, type="l", col="blue", lwd=2, ylab="Return",
main="Monthly Returns on SBUX")
line(sbux_ccret, type="l", col="blue", lwd=2)
line(sbux_ccret)
lines(sbux_ccret, type="l", col="blue", lwd=2)
lines(sbux_ccret)
? lines
lines(sbux_ccret, type="l", col="red")
lines(sbux_ccret, type="l", col="red", lwd=2)
sbux_gret = sbux_ret+1
sbux_gret.
sbux_gre
sbux_gret
sbux_fv = cumprod(sbux_gret)
sbux_fv
sbux
View(sbux_df)
View(sbux_df)
index_1=which(sbux_df$Date?c)
?c
x_vals = seq(-0.25, 0.35, length.out = 100)
MSFT = dnorm(x_vals, 0.05, 0.1)
SBUX = dnorm(x_vals, 0.025, 0.05)
# Normal curve for MSFT
plot(x_vals, MSFT, type = "l", col = "blue", ylab = "Normal curves",
ylim = c(0, 8))
# Add a normal curve for SBUX
# Add a plot legend
legend("topleft", legend = c("Microsoft", "Starbucks"),
col = c("blue", "red"), lty = 1)
lines(SBUX, type = "l", col = "red")
lines(SBUX, type = "l", col = "red")
SBUX = dnorm(x_vals, 0.025, 0.05)
SBUX
lines(SBUX, col = "red")
? lines
mu_R = 0.04
sigma_R = 0.09
W0 = 100000
qnorm(0.01, mu_R, sigma_R)
PA = c(38.23, 41.29)
PC = c(41.11, 41.74)
.
PA = c(38.23, 41.29)
PC = c(41.11, 41.74)
RA = (PA[1]-PA[0])/PA[0]
RC = (PC[1]-PC[0])/PC[0]
RA
RC
PA
PC
PA[1]
RA
RA=0.08004
RA_annual = (1+RA)^12-1
RA_annual
exp(log(1+RA))^12
exp(log(1+RA))^12-1
log(1+RA)
xA = 8000*(1+RA)
xC = 2000*(1+RC)
RA=0.08004
RC=0.01532
xA = 8000*(1+RA)
xA
xC = 2000*(1+RC)
xC
(xA+xC-10000)/10000
install.packages("PerformanceAnalytics")
install.packages("tseries")
# Load relevant packages
library(PerformanceAnalytics);library(zoo);library(tseries);
# Get the monthly adjusted closing price data on VBLTX, FMAGX and SBUX from Yahoo! using the tseries function get.hist.quote(). Set the sample to Jan 1998 through Dec 2009.
# Get the adjusted closing prices from Yahoo!
VBLTX_prices = get.hist.quote(instrument="vbltx", start="1998-01-01",end="2009-12-31", quote="AdjClose",provider="yahoo", origin="1970-01-01",compression="m", retclass="zoo")
FMAGX_prices = get.hist.quote(instrument="fmagx", start="1998-01-01",end="2009-12-31", quote="AdjClose",provider="yahoo", origin="1970-01-01",compression="m", retclass="zoo")
SBUX_prices = get.hist.quote(instrument="sbux", start="1998-01-01",end="2009-12-31", quote="AdjClose",provider="yahoo", origin="1970-01-01",compression="m", retclass="zoo")
# Change the class of the time index to yearmon which is appropriate for monthly data
# index() and as.yearmon() are functions in the zoo package
index(VBLTX_prices) = as.yearmon(index(VBLTX_prices))
index(FMAGX_prices)  = as.yearmon(index(FMAGX_prices))
index(SBUX_prices)  = as.yearmon(index(SBUX_prices))
# Inspect your data
start(SBUX_prices)
end(SBUX_prices)
# The variables VBLTX_prices, FMAGX_prices and SBUX_prices are preloaded in your workspace
# Create merged price data
all_prices = merge(VBLTX_prices, FMAGX_prices, SBUX_prices)
# Rename columns
colnames(all_prices) = c("VBLTX", "FMAGX", "SBUX")
# Calculate cc returns as difference in log prices
all_returns = diff(log(all_prices), 1)
# Look at the return data
start(all_returns)
end(all_returns)
colnames(all_returns)
head(all_returns)
chart.TimeSeries(all_returns, legend.loc="bottom", main=" ")
# The previous charts are a bit hard to read. The PerformanceAnalytics function
# chart.Bar makes it easier to compare the returns of different assets on the
# same plot
chart.Bar(all_returns, legend.loc="bottom", main=" ")
chart.TimeSeries(all_returns, legend.loc="bottom", main=" ")
chart.TimeSeries(all_returns, legend.loc="bottom", main=" ")
chart.Bar(all_returns, legend.loc="bottom", main=" ")
chart.CumReturns(simple_returns ,wealth.index=TRUE, main="Growth of $1")
simple_returns = diff(all_prices)/lag(all_prices, k=-1);
head(all_returns)
chart.CumReturns(simple_returns ,wealth.index=TRUE, main="Growth of $1")
# Create matrix with returns
return_matrix = coredata(all_returns);
View(return_matrix)
View(return_matrix)
# Show boxplot of three series on one plot
boxplot(return_matrix[,"VBLTX"], return_matrix[,"FMAGX"], return_matrix[,"SBUX"],
names=colnames(return_matrix), col="slateblue1")
# Do the same thing using the PerformanceAnalytics function chart.Boxplot
chart.Boxplot(return_matrix)
chart.Boxplot(all_returns)
chart.Boxplot(all_returns)
chart.Boxplot(return_matrix)
chart.Boxplot(return_matrix)
chart.Boxplot(all_returns)
chart.Boxplot(return_matrix)
chart.Boxplot(return_matrix)
# Create matrix with returns
return_matrix = coredata(all_returns);
summary(return_matrix)
# Compute descriptive statistics by column using the base R function apply()
args(apply)
apply(return_matrix, 2, mean)
apply(return_matrix, 2, var)
apply(return_matrix, 2, sd)
apply(return_matrix, 2, skewness)
apply(return_matrix, 2, kurtosis)
table.stats(all_returns)
library(PerformanceAnalytics);
table.stats(all_returns)
table.stats(return_matrix)
table.Stats(return_matrix)
table.Stats(return_matrix)
table.Stats(all_returns)
pairs(return_matrix, pch=16, col=slateblue1)
pairs(return_matrix, pch=16, col="slateblue1")
apply(return_matrix, 2, mean)
apply(return_matrix, 2, var)
apply(return_matrix, 2,var)
apply(return_matrix, 2,cor)
var(return_matrix)
cor(return_matrix)
cd C:\Users\tom\Google 雲端硬碟\Programming\R\R programming
cd "C:\Users\tom\Google 雲端硬碟\Programming\R\R programming"
cd "C:\Users\tom"
ls
ls ()
clear
clearAll()
View(return_matrix)
getwd
getwd()
setwd("C:\Users\tom\Google 雲端硬碟\Programming\R\R programming\rprog-data-specdata")
setwd("C:\\Users\\tom\\Google 雲端硬碟\\Programming\\R\\R programming\\rprog-data-specdata")
ls
ls ()
pollutantmean <- function(directory, pollutant, id = 1:332) {
## 'directory' is a character vector of length 1 indicating
## the location of the CSV files
## 'pollutant' is a character vector of length 1 indicating
## the name of the pollutant for which we will calculate the
## mean; either "sulfate" or "nitrate".
## 'id' is an integer vector indicating the monitor ID numbers
## to be used
## Return the mean of the pollutant across all monitors list
## in the 'id' vector (ignoring NA values)
## NOTE: Do not round the result!
setwd(directory);
for(i in id){
temp = read.csv(str_pad(i, 3, pad = "0")+".csv")
all = rbind(all, temp)
}
mean(all, na.rm=TRUE)
}
read.csv("001"+".csv")
read.csv(paste(c("001",".csv"))
paste(c("001",".csv")
paste(c("001",".csv")
)
paste(c("001",".csv"), sep='')
paste(c("001",".csv"), sep='', collapse=sep)
paste(c("001",".csv"), collapse=sep)
paste("001",".csv")
paste("001",".csv", sep='')
temp <- read.csv(paste(str_pad(i, 3, pad = "0"),".csv", sep='')
)
temp <- read.csv(paste(str_pad(i, 3, pad = "0"),".csv", sep=''))
sprintf('%03d.csv', 1)
temp <- read.csv(sprintf('%03d.csv', i))
temp <- read.csv(sprintf('%03d.csv', 1))
getwd()
setwd("C:\\Users\\tom\\Google 雲端硬碟\\Programming\\R\\R programming\\rprog-data-specdata\\specdata")
temp <- read.csv(sprintf('%03d.csv', 1))
all <- rbind(all, temp)
all = data.frame()
all <- rbind(all, temp)
all <- data.frame()
temp <- read.csv(sprintf('%03d.csv', 1))
all <- rbind(all, temp)
pos = names(all)[names=pollutant]
pos = names(all)[names=]
pos = names(all)[names='sulfate']
pos
pos = names(all)[names='nitrate']
pos
names(all)
names(all)[1]
pos = names(all)[names(all)='nitrate']
tab = names(all)
pos = tab[tab=pollutant]
pos
pos = tab[tab='nitrate']
pos
pos <- tab[tab='nitrate']
pos
pos <- tab[tab==pollutant]
pos <- tab[tab=='nitrate']
pos
pos <- tab==pollutant
pos <- tab=='nitrate'
pos
mean(all[pos], na.rm=TRUE)
all[pos]
mean(all[pos], na.rm=TRUE)
all[pos]
na.omit(all[pos])
mean(na.omit(all[pos]), na.rm=TRUE)
mean(na.omit(all[pos]))
mean(na.omit(all[pos]))
lapply(all[pos], mean, na.rm=TRUE)
source("../pollutantmean.R")
pollutantmean("specdata", "sulfate", 1:10)
source("../pollutantmean.R")
pollutantmean("specdata", "sulfate", 1:10)
pollutantmean("C:\\Users\\tom\\Google 雲端硬碟\\Programming\\R\\R programming\\rprog-data-specdata\\specdata", "sulfate", 1:10)
source("../pollutantmean.R")
pollutantmean("C:\\Users\\tom\\Google 雲端硬碟\\Programming\\R\\R programming\\rprog-data-specdata\\specdata", "sulfate", 1:10)
source("../pollutantmean.R")
pollutantmean("C:\\Users\\tom\\Google 雲端硬碟\\Programming\\R\\R programming\\rprog-data-specdata\\specdata", "sulfate", 1:10)
pollutantmean
source("../pollutantmean.R")
pollutantmean("C:\\Users\\tom\\Google 雲端硬碟\\Programming\\R\\R programming\\rprog-data-specdata\\specdata", "sulfate", 1:10)
source("../pollutantmean.R")
pollutantmean("C:\\Users\\tom\\Google 雲端硬碟\\Programming\\R\\R programming\\rprog-data-specdata\\specdata", "sulfate", 1:10)
pollutantmean("specdata", "nitrate", 70:72)
pollutantmean("C:\\Users\\tom\\Google 雲端硬碟\\Programming\\R\\R programming\\rprog-data-specdata\\specdata", "nitrate", 70:72)
pollutantmean("C:\\Users\\tom\\Google 雲端硬碟\\Programming\\R\\R programming\\rprog-data-specdata\\specdata", "nitrate", 3)
pollutantmean("C:\\Users\\tom\\Google 雲端硬碟\\Programming\\R\\R programming\\rprog-data-specdata\\specdata", "nitrate", 23)
source("../pollutantmean.R")
pollutantmean("C:\\Users\\tom\\Google 雲端硬碟\\Programming\\R\\R programming\\rprog-data-specdata\\specdata", "nitrate", 23)
pollutantmean("C:\\Users\\tom\\Google 雲端硬碟\\Programming\\R\\R programming\\rprog-data-specdata\\specdata", "nitrate", 70:72)
pollutantmean("C:\\Users\\tom\\Google 雲端硬碟\\Programming\\R\\R programming\\rprog-data-specdata\\specdata", "sulfate", 1:10)
source("complete.R")
source("complete.R")
getwd
getwd()
source("../complete.R")
complete(".", 1)
source("../complete.R")
complete(".", 1)
source("../complete.R")
complete(".", 1)
source("../complete.R")
complete(".", 1)
source("../complete.R")
complete(".", 1)
source("../complete.R")
complete(".", 1)
source("../complete.R")
complete(".", 1)
all <- data.frame(id=numeric(0), nobs=numeric(0))
all
temp <- read.csv(sprintf('%s/%03d.csv', directory, 1))
directory=.
directory="."
temp <- read.csv(sprintf('%s/%03d.csv', directory, i))
temp <- read.csv(sprintf('%s/%03d.csv', directory, 1))
temp
c(id=i, nobs=ncol(temp))
c(id=1, nobs=ncol(temp))
all <- rbind(all, c(id=i, nobs=ncol(temp)))
all <- rbind(all, c(id=1, nobs=ncol(temp)))
all
all <- data.frame(id=numeric(0), nobs=numeric(0))
al
all
c(id=1, nobs=ncol(temp))
all
all <- rbind(all, c(id=1, nobs=ncol(temp)))
all
v
names(all) <- ("id", "obs")
names(all) <- c("id", "obs")
all
sources(./complete.R)
source(./complete.R)
source("./complete.R")
source("../complete.R")
complete(".", 1)
source("../complete.R")
complete(".", 1)
temp <- read.csv(sprintf('%s/%03d.csv', directory, 1))
directory="."
temp <- read.csv(sprintf('%s/%03d.csv', directory, i))
temp <- read.csv(sprintf('%s/%03d.csv', directory, 1))
temp
head(temp)
pos <- !is.na(temp$Date) && !is.na(temp$sulfate) && !is.na(temp$nitrate) && !is.na(temp$ID)
pos
is.na(temp$Date)
!is.na(temp$Date) && !is.na(temp$sulfate)
!is.na(temp$Date) & !is.na(temp$sulfate)
pos <- !is.na(temp$Date) & !is.na(temp$sulfate) & !is.na(temp$nitrate) & !is.na(temp$ID)
pos
source("../complete.R")
complete(".", 1)
source("../complete.R")
source("../complete.R")
complete(".", 1)
temp <- read.csv(sprintf('%s/%03d.csv', '.', 1))
pos <- !is.na(temp$Date) & !is.na(temp$sulfate) & !is.na(temp$nitrate) & !is.na(temp$ID)
nrow(temp[pos])
nrow(temp[pos], )
nrow(temp[pos, ])
source("../complete.R")
complete(".", 1)
complete(".", c(2, 4, 8, 10, 12))
complete(".", 30:25)
complete(".", 3)
directory='.'
temp <- read.csv(sprintf('%s/%03d.csv', directory, 1))
nComplete <- sum(!is.na(temp$Date) & !is.na(temp$sulfate) & !is.na(temp$nitrate) & !is.na(temp$ID))
nComplete
result= numeric()
result
result = c(result, corr(temp$sulfate, temp$nitrate))
cor(temp$sulfate, temp$nitrate)
cor(temp$sulfate, temp$nitrate, na.rm=TRUE)
?cor
pos <- !is.na(temp$Date) & !is.na(temp$sulfate) & !is.na(temp$nitrate) & !is.na(temp$ID)
temp = temp[pos]
temp <- temp[pos, ]
result = c(result, cor(temp$sulfate, temp$nitrate))
result
directory='.'
source("../corr.R")
function(directory)
''
file.exists(sprintf('%s/%03d.csv', directory, i))
file.exists(sprintf('%s/%03d.csv', directory, 1))
file.exists(sprintf('%s/%03d.csv', directory, 333))
corr(directory)
corr(directory, 0)
corr(".", 0)
i <- i+1
source("../corr.R")
corr(".", 0)
cr <- corr(".", 150)
cr <- corr(".", 150)
source("../corr.R")
source("../corr.R")
source("../corr.R")
cr <- corr(".", 150)
source("../corr.R")
cr <- corr(".", 150)
cr <- corr(".", 150)
source("../corr.R")
cr <- corr(".", 150)
cr
head(cr)
source("../corr.R")
cr <- corr(".", 150)
cr
head(cr)
summary(cr)
source("../corr.R")
cr <- corr(".", 150)
head(cr)
summary(cr)
source("../corr.R")
cr <- corr(".", 150)
summary(cr)
cr <- corr("specdata", 400)
head(cr)
cr <- corr(".", 400)
summary(cr)
cr <- corr(".", 5000)
summary(cr)
cr <- corr(".")
summary(cr)
length(cr)
source("../corr.R")
cr <- corr(".")
summary(cr)
length(cr)
pollutantmean <- function(directory, pollutant, id = 1:332) {
## 'directory' is a character vector of length 1 indicating
## the location of the CSV files
## 'pollutant' is a character vector of length 1 indicating
## the name of the pollutant for which we will calculate the
## mean; either "sulfate" or "nitrate".
## 'id' is an integer vector indicating the monitor ID numbers
## to be used
## Return the mean of the pollutant across all monitors list
## in the 'id' vector (ignoring NA values)
## NOTE: Do not round the result!
all <- data.frame()
for(i in id){
temp <- read.csv(sprintf('%s/%03d.csv', directory, i))
all <- rbind(all, temp)
}
tab <- names(all)
pos <- tab==pollutant
as.numeric(lapply(all[pos], mean, na.rm=TRUE))
}
complete <- function(directory, id = 1:332) {
## 'directory' is a character vector of length 1 indicating
## the location of the CSV files
## 'id' is an integer vector indicating the monitor ID numbers
## to be used
## Return a data frame of the form:
## id nobs
## 1  117
## 2  1041
## ...
## where 'id' is the monitor ID number and 'nobs' is the
## number of complete cases
all <- data.frame(id=numeric(0), nobs=numeric(0))
for(i in id){
temp <- read.csv(sprintf('%s/%03d.csv', directory, i))
pos <- !is.na(temp$Date) & !is.na(temp$sulfate) & !is.na(temp$nitrate) & !is.na(temp$ID)
all <- rbind(all, c(i, nrow(temp[pos, ])))
}
names(all) <- c("id", "obs")
all
}
source("http://d396qusza40orc.cloudfront.net/rprog%2Fscripts%2Fsubmitscript1.R")
submit()
submit()
install.packages("bitops")
install.packages("bitops")
submit()
install.packages("C:/Users/tom/Downloads/bitops_1.0-6.zip", repos = NULL)
submit()
